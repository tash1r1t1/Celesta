<!DOCTYPE html>
<html>
<head>
    <title>CELESTA</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            height: 100vh;

        } 

        #renderCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        #background-menu {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
        }

        #background-select {
            display: none;
            position: absolute;
            top: 30px;
            left: 0;
            z-index: 1001;
            background-color: white;
            padding: 5px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .background-thumbnails {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .background-thumbnail {
            width: 50px;
            height: 50px;
            cursor: pointer;
        }

        #select-background-btn {
            cursor: pointer;
            padding: 5px 10px;
            border: none;
            background-color: #007bff;
            color: white;
            border-radius: 5px;
        }
        #UI {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 1000;
        }

        #canvasContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #record-btn {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            cursor: pointer;
            padding: 10px 20px;
            border: none;
            background-color: #007bff;
            color: white;
            border-radius: 5px;
            font-size: 16px;
        }

        #melodies-list {
            position: fixed;
            bottom: 80px;
            left: 100px; 
            transform: translateX(-50%);
            list-style-type: none;
            padding: 0;
            max-width: 200px; 
            width: 30%;
            overflow-y: auto;
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .melody-item {
            padding: 10px;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
        }

        .melody-item button {
            cursor: pointer;
            padding: 5px 10px;
            border: none;
            background-color: #007bff;
            color: white;
            border-radius: 3px;
        }

        #background-menu {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
        }

        #background-select {
            display: none;
            position: absolute;
            top: 30px;
            right: 0;
            z-index: 1001;
            background-color: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .background-thumbnails {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .background-thumbnail {
            width: 50px;
            height: 50px;
            cursor: pointer;
            border-radius: 5px;
            transition: transform 0.3s ease;
        }

        .background-thumbnail:hover {
            transform: scale(1.1);
        }
    </style>

    <link rel="icon" type="image/png" href="models/logo_celesta.png" sizes="16x16">
</head>
<body>
    <div id="UI"></div>
    <div id="canvasContainer">
        <canvas id="renderCanvas"></canvas>
    </div>

    <button id="record-btn">Start Recording</button>
    <ul id="melodies-list"></ul>
    <div id="background-menu">
        <button id="select-background-btn">Select Background</button>
        <div id="background-select">
            <div class="background-thumbnails">
                <img src="background/back1.jpg" class="background-thumbnail" data-src="background/back1.jpg">
                <img src="background/back2.jpg" class="background-thumbnail" data-src="background/back2.jpg">
                <img src="background/back3.jpg" class="background-thumbnail" data-src="background/back3.jpg">
                <img src="background/back4.jpg" class="background-thumbnail" data-src="background/back4.jpg">
                <img src="background/back5.jpg" class="background-thumbnail" data-src="background/back5.jpg">
            </div>
        </div>
    </div>
    <script type="text/javascript">
        // Конфігурація параметрів клавіш, включаючи тип (біла чи чорна), ноту, розміри та позиції.
        const keyParams = [
            { type: "white", note: "C", topWidth: 1.4, bottomWidth: 2.3, topPositionX: -0.45, wholePositionX: -14.4 },
            { type: "black", note: "C#", wholePositionX: -13.45 },
            { type: "white", note: "D", topWidth: 1.4, bottomWidth: 2.4, topPositionX: 0, wholePositionX: -12 },
            { type: "black", note: "D#", wholePositionX: -10.6 },
            { type: "white", note: "E", topWidth: 1.4, bottomWidth: 2.3, topPositionX: 0.45, wholePositionX: -9.6 },
            { type: "white", note: "F", topWidth: 1.3, bottomWidth: 2.4, topPositionX: -0.55, wholePositionX: -7.2 },
            { type: "black", note: "F#", wholePositionX: -6.35 },
            { type: "white", note: "G", topWidth: 1.3, bottomWidth: 2.3, topPositionX: -0.2, wholePositionX: -4.8 },
            { type: "black", note: "G#", wholePositionX: -3.6 },
            { type: "white", note: "A", topWidth: 1.3, bottomWidth: 2.3, topPositionX: 0.2, wholePositionX: -2.4 },
            { type: "black", note: "A#", wholePositionX: -0.85 },
            { type: "white", note: "B", topWidth: 1.3, bottomWidth: 2.4, topPositionX: 0.55, wholePositionX: 0 },
        ]
        // Відповідність клавіш на клавіатурі їхнім музичним значенням.
        const keyMappings = {
            "1": "C#3",
            "2": "D3",
            "3": "D#3",
            "4": "E3",
            "5": "F3",
            "6": "F#3",
            "7": "G2",
            "8": "G#2",
            "9": "A2",
            "0": "C3",
            "-": "A5",
            "=": "C4",
            "`": "A#5",
            "q": "G4",
            "w": "C#6",
            "e": "G3",
            "r": "G#4",
            "t": "A#4",
            "y": "D#6",
            "u": "B4",
            "i": "B3",
            "o": "F5",
            "p": "F#5",
            "a": "D#4",
            "s": "A4",
            "d": "F#4",
            "f": "G#3",
            "g": "A3",
            "h": "A#3",
            "j": "C5",
            "k": "C#5",
            "l": "D5",
            ";": "A#2",
            "'": "G#5",
            "\\": "F#6",
            "z": "E6",
            "x": "D6",
            "c": "F4",
            "v": "C6",
            "b": "E4",
            "n": "E5",
            "m": "D#5",
            ",": "B2",
            ".": "C#4",
            "/": "D4",
            "[": "F6",
            "]": "G5",
            " ": "B5"

        };
        // Змінні та елементи DOM для роботи з сценою та записом мелодій.
        let scene;
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);

        // Функція для створення сцени та камери з подіями для зміни фону та взаємодії з музичною клавіатурою.
        const createScene = async function (engine) {

            scene = new BABYLON.Scene(engine);
            const alpha = 3 * Math.PI / 2;
            const beta = Math.PI / 50;
            const radius = 220;
            const target = new BABYLON.Vector3(0, 0, 0);
            const camera = new BABYLON.ArcRotateCamera("Camera", alpha, beta, radius, target, scene);
            camera.attachControl(canvas, true);

            // Загрузка фонового зображення та налаштування сцени.
            let backgroundTexture = new BABYLON.Texture("background/back1.jpg", scene);
            scene.clearColor = new BABYLON.Color4(0, 0, 0, 0); 
            scene.backgroundTexture = backgroundTexture;

            // Обробники подій для зміни фонового зображення.
            document.addEventListener('DOMContentLoaded', function () {
                const thumbnails = document.querySelectorAll('.background-thumbnail');
                const backgroundSelect = document.getElementById('background-select');
                const canvasContainer = document.getElementById('canvasContainer');

                function setBackground(imageUrl) {
                    if (scene.backgroundTexture) {
                    scene.backgroundTexture.dispose();
                }
                    document.body.style.backgroundImage = `url(${imageUrl})`;
                }

                function thumbnailClickHandler() {
                    const selectedSrc = this.getAttribute('data-src');
                    setBackground(selectedSrc);
                    backgroundSelect.style.display = 'none';
                }

                thumbnails.forEach(thumbnail => {
                thumbnail.addEventListener('click', function () {
                    const selectedSrc = this.getAttribute('data-src');
                    setBackground(selectedSrc);
                    backgroundSelect.style.display = 'none'; 
                });
            });

            const selectBackgroundBtn = document.getElementById('select-background-btn');
            selectBackgroundBtn.addEventListener('click', function () {
                backgroundSelect.style.display = 'block'; 
            });
        });
            // Створення світла та клавіатури.
            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
            light.intensity = 0.6;

            // Створення вузла клавіатури та графічного інтерфейсу користувача для клавіатури.
            const keyboard = new BABYLON.TransformNode("keyboard");

            const gui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

            // Функція для створення клавіш з вказаними параметрами та текстом.
            const buildKey = function (scene, parent, props, gui, text) {
                if (props.type === "white") {// Логіка створення білої клавіші та текстового блоку.
                    const bottom = BABYLON.MeshBuilder.CreateBox("whiteKeyBottom", { width: props.bottomWidth, height: 2, depth: 6.5 }, scene);

                    const top = BABYLON.MeshBuilder.CreateBox("whiteKeyTop", { width: props.topWidth, height: 2, depth: 6.5 }, scene);
                    top.position.z = 4.75;
                    top.position.x += props.topPositionX;

                    const key = BABYLON.Mesh.MergeMeshes([bottom, top], true, false, null, false, false);
                    key.position.x = props.referencePositionX + props.wholePositionX;
                    key.name = props.note + props.register;
                    key.parent = parent;

                    const container = new BABYLON.GUI.Rectangle();
                    container.width = `${props.bottomWidth * 100}%`;
                    container.height = "100%";
                    container.background = "transparent";
                    container.color = "rgba(0, 0, 0, 0)";
                    container.linkOffsetY = 15; 

                    const textBlock = new BABYLON.GUI.TextBlock();
                    textBlock.text = String.fromCharCode(text);
                    textBlock.color = (props.type === "black") ? "white" : "black";
                    textBlock.fontSize = 22;
                    textBlock.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
                    textBlock.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;

                    container.addControl(textBlock);
                    gui.addControl(container);

                    container.linkWithMesh(key);
                    container.isPointerBlocker = false;

                    return key;
                } else if (props.type === "black") {// Логіка створення чорної клавіші та текстового блоку.
                    const blackMat = new BABYLON.StandardMaterial("black");
                    blackMat.diffuseColor = new BABYLON.Color3(0, 0, 0);

                    const key = BABYLON.MeshBuilder.CreateBox(props.note + props.register, { width: 1.4, height: 3, depth: 6.5 }, scene);
                    key.position.z += 4.75;
                    key.position.y += 0.25;
                    key.position.x = props.referencePositionX + props.wholePositionX;
                    key.material = blackMat;
                    key.parent = parent;
                    key.name = props.note + props.register;

                    const container = new BABYLON.GUI.Rectangle();
                    container.width = "100%";
                    container.height = "100%";
                    container.background = "transparent";
                    container.color = "rgba(0, 0, 0, 0)";
                    container.linkOffsetY = 15; 

                    const textBlock = new BABYLON.GUI.TextBlock();
                    textBlock.text = String.fromCharCode(text);
                    textBlock.color = (props.type === "black") ? "white" : "black";
                    textBlock.fontSize = 22;
                    textBlock.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
                    textBlock.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;

                    container.addControl(textBlock);
                    gui.addControl(container);

                    container.linkWithMesh(key);
                    container.isPointerBlocker = false;

                    return key;
                }
            };

            // Змінні для позицій та тексту клавіш.
            let referencePositionX = -2.4 * 7;
            let num = 0;
            let text_note = 48;
            let text = 0;

            // Цикл для створення клавіш на клавіатурі за вказаними параметрами.
            for (let register = 3, register1 = 2; register <= 6; register++, register1++) {
                num = 0;
                keyParams.forEach(key => {// Логіка визначення параметрів клавіші та тексту для клавіші.
                    let keyParams = {
                        register: (num >= 7) ? register1 : register,
                        referencePositionX: referencePositionX,
                        ...key
                    };
                    if (text_note == 58 || text_note == 64) {
                        text_note++;
                        text = text_note;
                    }
                    else if (text_note == 94) {
                        text = 39;
                    }
                    else if (text_note == 97) {
                        text = 32;
                    }
                    else if (text_note == 95) {
                        text = 45;
                    }
                    else if (text_note == 60) {
                        text = 44;
                    }
                    else if (text_note == 62) {
                        text = 46;
                    }
                    else if (text_note == 63) {
                        text = 47;
                    }
                    else {
                        text = text_note;
                    }
                    buildKey(scene, keyboard, keyParams, gui, text);
                    text_note++;
                    num++;
                });
                referencePositionX += 2.4 * 7;
            }

            // Завантаження моделі Celesta та її розміщення в сцені.
            const celesta = new BABYLON.TransformNode("celesta");
            BABYLON.SceneLoader.ImportMesh("", "models/", "Celesta.glb", scene, function (meshes) {
                meshes.forEach(function (mesh) {
                    mesh.parent = celesta;
                    mesh.scaling = new BABYLON.Vector3(1.55, 1.55, 1.8);
                    mesh.position.y = -48;
                    mesh.position.z = 106;
                    mesh.position.x = -80;
                });
                celesta.rotation.y = Math.PI / 2;
            });

            // Створення мапи для відслідковування клавіш та обробники подій натискання клавіш.
            const pointerToKey = new Map();
            const pressedKeys = {};
            const isPlaying = {}; 

            // Обробники подій натискання та відпускання клавіш на клавіатурі.
            function keyDownHandler(event) {
                const keyCode = event.key;
                const pianoKeyName = keyMappings[keyCode];
                if (pianoKeyName && !pressedKeys[keyCode]) {
                    pressedKeys[keyCode] = true;
                    const pianoKeyMesh = scene.getMeshByName(pianoKeyName);
                    if (pianoKeyMesh) {
                        pianoKeyMesh.position.y -= 0.5;
                    }
                    playAudio(pianoKeyName);
                    event.preventDefault();
                    return false;
                }
            }

            function keyUpHandler(event) {
                const keyCode = event.key;
                const pianoKeyName = keyMappings[keyCode];
                if (pianoKeyName && pressedKeys[keyCode]) {
                    pressedKeys[keyCode] = false;
                    const pianoKeyMesh = scene.getMeshByName(pianoKeyName);
                    if (pianoKeyMesh) {
                        pianoKeyMesh.position.y += 0.5;
                    }
                    const keyData = pointerToKey.get(pianoKeyName);
                    if (keyData && keyData.audio) {
                        stopAudio(pianoKeyName);
                    }
                    event.preventDefault();
                    return false;
                }
            }

            window.addEventListener('keydown', keyDownHandler);
            window.addEventListener('keyup', keyUpHandler);

            // Функції для відтворення та зупинки аудіо під час натискання клавіш.
            function playAudio(pianoKeyName) {
                if (!isPlaying[pianoKeyName]) {
                    const musicFileName = `${encodeURIComponent(pianoKeyName)}.wav`;
                    const audio = new Audio();
                    audio.src = `sound/${musicFileName}`;
                    audio.play();

                    currentAudio = audio;
                    isPlaying[pianoKeyName] = true;
                    pointerToKey.set(pianoKeyName, { audio: audio });
                }
            }

            function stopAudio(pianoKeyName) {
                const keyData = pointerToKey.get(pianoKeyName);
                if (keyData && keyData.audio && isPlaying[pianoKeyName]) {

                    setTimeout(() => {
                        keyData.audio.pause();
                        keyData.audio.currentTime = 0;
                        isPlaying[pianoKeyName] = false;
                        pointerToKey.delete(pianoKeyName);
                        currentAudio = null;
                    }, 1000);
                }
            }

            // Обробник подій для клавіатури з можливістю взаємодії з клавішами.
            scene.onPointerObservable.add((pointerInfo) => {
                switch (pointerInfo.type) {
                    case BABYLON.PointerEventTypes.POINTERDOWN:
                        if (pointerInfo.pickInfo.hit) {
                            let pickedMesh = pointerInfo.pickInfo.pickedMesh;
                            let pointerId = pointerInfo.event.pointerId;
                            if (pickedMesh.parent === keyboard) {
                                pickedMesh.position.y -= 0.5;
                                const pianoKeyName = pickedMesh.name;
                                playAudio(pianoKeyName);
                                pointerToKey.set(pointerId, { mesh: pickedMesh });
                            }
                        }
                        break;
                    case BABYLON.PointerEventTypes.POINTERUP:
                        let pointerIdUp = pointerInfo.event.pointerId;
                        if (pointerToKey.has(pointerIdUp)) {
                            const keyData = pointerToKey.get(pointerIdUp);
                            if (keyData && keyData.mesh) {
                                keyData.mesh.position.y += 0.5;
                                stopAudio(keyData.mesh.name);
                                pointerToKey.delete(pointerIdUp);
                            }
                        }
                        break;
                }
            });

            // Створення досвіду розширеної реальності (XR) для сцени.
            const xrHelper = await scene.createDefaultXRExperienceAsync();
            // Повернення створеної сцени для відображення у вікні браузера.
            return scene;
        }

        // Змінні та функції для запису та відтворення мелодій.
        let isRecording = false; 
        let melodies = []; 
        const melodiesList = document.getElementById('melodies-list');
        const recordedAudio = document.getElementById('recordedAudio');
        const recordBtn = document.getElementById('record-btn');
        let mediaRecorder;
        let recordedChunks = [];
        
        // Функція для початку або зупинки запису мелодій.
        async function toggleRecording() {
            if (!mediaRecorder) {
                await startRecording(); 
            } else {
                stopRecording(); 
                await startRecording(); 
            }
        }

        async function toggleRecording() {
    if (!isRecording) {
        await startRecording(); 
    } else {
        stopRecording();
    }
}

// Функція для початку запису мелодій
async function startRecording() {
    recordedChunks = []; 

    try {
        const stream = await navigator.mediaDevices.getDisplayMedia({ audio: true });
        mediaRecorder = new MediaRecorder(stream);

        mediaRecorder.ondataavailable = function (event) {
            if (event.data.size > 0) {
                recordedChunks.push(event.data);
            }
        };

        mediaRecorder.onstop = function () {
            const blob = new Blob(recordedChunks, { type: 'audio/wav' });
            const url = URL.createObjectURL(blob);
            const audio = new Audio();
            audio.src = url;
            melodies.push(audio);

            renderMelodies();
        };

        mediaRecorder.start();
        recordBtn.textContent = 'Stop Recording';
        isRecording = true;
    } catch (error) {
        console.error('Error accessing display media:', error);
    }
}

// Функція для зупинки запису мелодій.
function stopRecording() {
    if (mediaRecorder && mediaRecorder.state === 'recording') {
        mediaRecorder.stop();
        recordBtn.textContent = 'Start Recording'; 
        isRecording = false; 
    }
}


function handleDataAvailable(event) {
    if (event.data.size > 0) {
        recordedChunks.push(event.data);
        const blob = new Blob(recordedChunks, { type: 'audio/wav' });
        const url = URL.createObjectURL(blob);
        recordedAudio.src = url;
        recordedAudio.controls = true;
        addMelodyToList(recordedChunks);
    }
}

recordBtn.addEventListener('click', toggleRecording);

// Додавання записаної мелодії до списку для відтворення.
function addMelodyToList(melody) {
    melodies.push(melody); 
    renderMelodies(); 
}

// Оновлення відображення списку записаних мелодій на сторінці.
function renderMelodies() {
    melodiesList.innerHTML = ''; 
    melodies.forEach((melody, index) => {
        const item = document.createElement('li');
        item.classList.add('melody-item');
        item.textContent = 'Recorded Melody ' + (index + 1);

        const playBtn = document.createElement('button');
        playBtn.textContent = 'Play';
        playBtn.addEventListener('click', () => playMelody(melody)); 

        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = 'Delete';
        deleteBtn.addEventListener('click', () => deleteMelody(index)); 

        item.appendChild(playBtn);
        item.appendChild(deleteBtn);
        melodiesList.appendChild(item);
    });
}

// Відтворення обраної мелодії.
function playMelody(melody) {
    melody.play();
}

// Видалення обраної мелодії зі списку.
function deleteMelody(index) {
    melodies.splice(index, 1);
    renderMelodies(); 
}

renderMelodies();

// Створення сцени та рендеринг у вікні браузера.
createScene(engine).then(sceneToRender => {
    engine.runRenderLoop(() => sceneToRender.render());
});

// Обробник зміни розміру вікна браузера для адаптації сцени.
window.addEventListener("resize", function () {
    engine.resize();
});
</script>
</body>
</html>
